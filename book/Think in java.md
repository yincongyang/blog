# Think in Java

##1、对象

- 对象的成员变量作用域有4个：显式作用域（private，protect，public），隐式作用域（friendly）

##2、一切都是对象

- 句柄操作对象。也就是说，只是由于拥有一个句柄，并不表示必须有一个对象同它连接。因此，创建一个句柄时，记住无论如何都进行初始化。
- 数据存储区域与职责
>	(1) 寄存器。这是最快的保存区域，因为它位于和其他所有保存方式不同的地方：处理器内部。然而，寄存
	器的数量十分有限，所以寄存器是根据需要由编译器分配。我们对此没有直接的控制权，也不可能在自己的
	程序里找到寄存器存在的任何踪迹。
	(2) 堆栈。驻留于常规RAM（随机访问存储器）区域，但可通过它的“堆栈指针”获得处理的直接支持。堆
	栈指针若向下移，会创建新的内存；若向上移，则会释放那些内存。这是一种特别快、特别有效的数据保存
	方式，仅次于寄存器。创建程序时，Java 编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存
	在时间”。这是由于它必须生成相应的代码，以便向上和向下移动指针。这一限制无疑影响了程序的灵活
	性，所以尽管有些Java 数据要保存在堆栈里——特别是对象句柄，但Java 对象并不放到其中。
	47
	(3) 堆。一种常规用途的内存池（也在RAM 区域），其中保存了Java 对象。和堆栈不同，“内存堆”或
	“堆”（Heap）最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要
	在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new 命
	令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然
	会付出一定的代价：在堆里分配存储空间时会花掉更长的时间！
	(4) 静态存储。这儿的“静态”（Static）是指“位于固定位置”（尽管也在RAM 里）。程序运行期间，静
	态存储的数据将随时等候调用。可用static 关键字指出一个对象的特定元素是静态的。但Java 对象本身永
	远都不会置入静态存储空间。
	(5) 常数存储。常数值通常直接置于程序代码内部。这样做是安全的，因为它们永远都不会改变。有的常数
	需要严格地保护，所以可考虑将它们置入只读存储器（ROM）。
	(6) 非RAM 存储。若数据完全独立于一个程序之外，则程序不运行时仍可存在，并在程序的控制范围之外。
	其中两个最主要的例子便是“流式对象”和“固定对象”。对于流式对象，对象会变成字节流，通常会发给
	另一台机器。而对于固定对象，对象保存在磁盘中。即使程序中止运行，它们仍可保持自己的状态不变。对
	于这些类型的数据存储，一个特别有用的技巧就是它们能存在于其他媒体中。一旦需要，甚至能将它们恢复
	成普通的、基于RAM 的对象。Java 1.1 提供了对Lightweight persistence 的支持。未来的版本甚至可能提
	供更完整的方案。
	

- 主要类型:不通过包装类声明的变量保存在`堆栈`中，通过包装类声明则保存在`堆`中。
>BigInteger、BigDecimal两者都没有对应的“主类型”。这两个类都有自己特殊的“方法”，对应于我们针对主类型执行的操作。
也就是说，能对int 或float 做的事情，对BigInteger 和BigDecimal 一样可以做。只是必须使用方法调用，不能使用运算符。此外，由于牵
涉更多，所以运算速度会慢一些。我们牺牲了速度，但换来了精度。
BigInteger 支持任意精度的整数。
BigDecimal 支持任意精度的定点数字。例如，可用它进行精确的币值计算。
