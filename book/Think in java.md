# Think in Java

## 1、对象

- 对象的成员变量作用域有4个：显式作用域（private，protect，public），隐式作用域（friendly）

## 2、一切都是对象

- 句柄操作对象。也就是说，只是由于拥有一个句柄，并不表示必须有一个对象同它连接。因此，创建一个句柄时，记住无论如何都进行初始化。
- 数据存储区域与职责
>	(1) 寄存器。这是最快的保存区域，因为它位于和其他所有保存方式不同的地方：处理器内部。然而，寄存
	器的数量十分有限，所以寄存器是根据需要由编译器分配。我们对此没有直接的控制权，也不可能在自己的
	程序里找到寄存器存在的任何踪迹。
	(2) 堆栈。驻留于常规RAM（随机访问存储器）区域，但可通过它的“堆栈指针”获得处理的直接支持。堆
	栈指针若向下移，会创建新的内存；若向上移，则会释放那些内存。这是一种特别快、特别有效的数据保存
	方式，仅次于寄存器。创建程序时，Java 编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存
	在时间”。这是由于它必须生成相应的代码，以便向上和向下移动指针。这一限制无疑影响了程序的灵活
	性，所以尽管有些Java 数据要保存在堆栈里——特别是对象句柄，但Java 对象并不放到其中。
	47
	(3) 堆。一种常规用途的内存池（也在RAM 区域），其中保存了Java 对象。和堆栈不同，“内存堆”或
	“堆”（Heap）最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要
	在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new 命
	令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然
	会付出一定的代价：在堆里分配存储空间时会花掉更长的时间！
	(4) 静态存储。这儿的“静态”（Static）是指“位于固定位置”（尽管也在RAM 里）。程序运行期间，静
	态存储的数据将随时等候调用。可用static 关键字指出一个对象的特定元素是静态的。但Java 对象本身永
	远都不会置入静态存储空间。
	(5) 常数存储。常数值通常直接置于程序代码内部。这样做是安全的，因为它们永远都不会改变。有的常数
	需要严格地保护，所以可考虑将它们置入只读存储器（ROM）。
	(6) 非RAM 存储。若数据完全独立于一个程序之外，则程序不运行时仍可存在，并在程序的控制范围之外。
	其中两个最主要的例子便是“流式对象”和“固定对象”。对于流式对象，对象会变成字节流，通常会发给
	另一台机器。而对于固定对象，对象保存在磁盘中。即使程序中止运行，它们仍可保持自己的状态不变。对
	于这些类型的数据存储，一个特别有用的技巧就是它们能存在于其他媒体中。一旦需要，甚至能将它们恢复
	成普通的、基于RAM 的对象。Java 1.1 提供了对Lightweight persistence 的支持。未来的版本甚至可能提
	供更完整的方案。
	

- 主要类型:不通过包装类声明的变量保存在`堆栈`中，通过包装类声明则保存在`堆`中。
>BigInteger、BigDecimal两者都没有对应的“主类型”。这两个类都有自己特殊的“方法”，对应于我们针对主类型执行的操作。
也就是说，能对int 或float 做的事情，对BigInteger 和BigDecimal 一样可以做。只是必须使用方法调用，不能使用运算符。此外，由于牵
涉更多，所以运算速度会慢一些。我们牺牲了速度，但换来了精度。
BigInteger 支持任意精度的整数。
BigDecimal 支持任意精度的定点数字。例如，可用它进行精确的币值计算。
主类型 默认值
Boolean false
Char '\u0000'(null)
byte (byte)0
short (short)0
int 0
long 0L
float 0.0f
double 0.0d

- Java 封装器能做的唯一事情就是将其初始化成一个特定的值，然后读取那个值。

- java数组与C++有区别，可以保证数组是可安全操作的。
>java创建对象数组时，实际创建的是一个句柄数组。而且每个句柄都会自动初始化成一个特殊值，并带有自己的
关键字：null（空）。一旦Java 看到null，就知道该句柄并未指向一个对象。正式使用前，必须为每个句
柄都分配一个对象。若试图使用依然为null 的一个句柄，就会在运行期报告问题。因此，典型的数组错误在
Java 里就得到了避免。

-java对象作用域与持有对象的句柄作用域（生命周期）不同。句柄的作用域结束时，其所持有的对象仍然会保存在内存中，直到垃圾回收机制去处理。

-static关键字：
>static声明的数据成员和方法，与该类的任何对象无关。自声明时便自动占据一个存储空间，多个对象只共享这一个空间。静态方法不可访问非静态的成员变量
和其他任何方法一样，static 方法也能创建自己类型的命名对象。所以经常把static 方法作为一个“领头羊”使用，用它生成一系列自己类型的“实例

## 3、控制语句

## 4、初始化和清除

## 5、隐藏实施过程

- 进行面向对象的设计时，一项基本的考虑是：如何将发生变化的东西与保持不变的东西分隔开。

## 6、类再生

- 继承与合成
- final关键字
> (1) 编译期常数，它永远不会改变
  (2) 在运行期初始化的一个值，我们不希望它发生变化
对于编译期的常数，编译器（程序）可将常数值“封装”到需要的计算过程里。也就是说，计算可在编译期
间提前执行，从而节省运行时的一些开销。在Java 中，这些形式的常数必须属于基本数据类型
（Primitives），而且要用final 关键字进行表达。在对这样的一个常数进行定义的时候，必须给出一个值。
无论static 还是final 字段，都只能存储一个数据，而且不得改变。
若随同对象句柄使用final，而不是基本数据类型，它的含义就稍微让人有点儿迷糊了。对于基本数据类
型，final 会将值变成一个常数；但对于对象句柄，final 会将句柄变成一个常数。进行声明时，必须将句柄
初始化到一个具体的对象。而且永远不能将句柄变成指向另一个对象。然而，对象本身是可以修改的。Java
对此未提供任何手段，可将一个对象直接变成一个常数（但是，我们可自己编写一个类，使其中的对象具有
“常数”效果）。这一限制也适用于数组，它也属于对象。

- 集合类只能容纳对象句柄。但对一个数组，却既可令其直接容纳基本类型的数据，亦可容纳指向对象的句
柄。利用象Integer、Double 之类的“封装器”类，可将基本数据类型的值置入一个集合里

- 为容纳一组对象，最适宜的选择应当是数组。而且假如容纳的是一系列基本数据类型，更是必须采用数组。
当我们编写程序时，通常并不能确切地知道最终需要多少个对象。有些时候甚至想用更复杂的方式来保存对象。为解决这个
问题，Java 提供了四种类型的“集合类”：Vector（矢量）、BitSet（位集）、Stack（堆栈）以及Hashtable（散列表）。

- instanceof 关键字













